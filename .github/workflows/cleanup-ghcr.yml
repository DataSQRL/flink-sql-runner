name: Cleanup GHCR Images

on:
  workflow_dispatch: # Allows manual triggering
  schedule:
    - cron: '0 0 * * 0'

jobs:
  cleanup-images:
    name: Cleanup GHCR Images
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get all container packages in the organization
        id: get-packages
        run: |
          set +e  # Don't exit on error
          echo "Attempting to fetch container packages..."

          # Try organization packages first
          package_names=$(gh api /orgs/DataSQRL/packages?package_type=container --jq '.[].name' 2>&1)
          exit_code=$?

          if [ $exit_code -ne 0 ]; then
            echo "Organization endpoint failed, trying repository endpoint..."
            package_names=$(gh api /repos/DataSQRL/flink-sql-runner/packages?package_type=container --jq '.[].name' 2>&1)
            exit_code=$?
          fi

          if [ $exit_code -ne 0 ]; then
            echo "Failed to fetch packages from both endpoints"
            echo "Error: $package_names"
            package_names=""
          else
            echo "Successfully fetched packages:"
            echo "$package_names"
          fi

          # Save packages to output (will be empty if both failed)
          {
            echo "packages<<EOF"
            echo "$package_names"
            echo "EOF"
          } >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.PACKAGES_BOT_PAT }}

      - name: Delete untagged images (safe for multi-arch)
        run: |
          set -euo pipefail

          packages="${{ steps.get-packages.outputs.packages }}"
          if [ -z "$packages" ]; then
            echo "No packages found to clean up"
            exit 0
          fi

          # Login to GHCR so we can inspect manifest lists for protected tags
          GH_USERNAME=$(gh api user --jq .login)
          echo "$GH_TOKEN" | docker login ghcr.io -u "$GH_USERNAME" --password-stdin

          # Tags we NEVER want to break by deleting their referenced manifests.
          # - *-SNAPSHOT (e.g. 1.0-SNAPSHOT)
          # - semver-flavored flink tags (e.g. 0.9.3-flink-2.2)
          PROTECTED_TAG_REGEX='(-SNAPSHOT$)|(^v?[0-9]+\.[0-9]+\.[0-9]+-flink-[0-9]+(\.[0-9]+)*$)'

          for pkg in $packages; do
            echo "--- Processing package: $pkg ---"

            versions_json=""
            chosen_endpoint=""

            # Pick the first endpoint that successfully returns versions
            for endpoint in "/orgs/DataSQRL" "/repos/DataSQRL/flink-sql-runner"; do
              echo "Trying endpoint: $endpoint"
              if versions_json=$(gh api --paginate "$endpoint/packages/container/$pkg/versions" 2>/dev/null | jq -s 'add'); then
                chosen_endpoint="$endpoint"
                break
              fi
            done

            if [ -z "$chosen_endpoint" ]; then
              echo "Could not fetch versions for $pkg from any endpoint; skipping"
              echo "--- Finished processing $pkg ---"
              continue
            fi

            echo "Using endpoint: $chosen_endpoint"

            # Find protected tags present on this package
            protected_tags=$(echo "$versions_json" | jq -r --arg re "$PROTECTED_TAG_REGEX" '
              .[] | .metadata.container.tags[]? | select(test($re))
            ' | sort -u)

            # Compute all manifest digests referenced by protected tags (includes per-arch manifests)
            protected_digests=""
            if [ -n "$protected_tags" ]; then
              echo "Protected tags for $pkg:"
              echo "$protected_tags"

              inspect_failed=false
              for tag in $protected_tags; do
                image_ref="ghcr.io/datasqrl/$pkg:$tag"

                # Top-level digest for the tag (manifest list digest for multi-arch)
                top_digest=$(docker buildx imagetools inspect "$image_ref" --format '{{.Digest}}' 2>/dev/null || true)

                # If multi-arch, collect child manifest digests
                child_digests=$(docker buildx imagetools inspect "$image_ref" --raw 2>/dev/null | jq -r '.manifests[]?.digest' 2>/dev/null || true)

                if [ -z "$top_digest" ] && [ -z "$child_digests" ]; then
                  echo "WARNING: failed to inspect protected tag $image_ref; skipping deletions for $pkg to avoid breaking protected tags"
                  inspect_failed=true
                  break
                fi

                protected_digests=$(printf "%s\n%s\n%s\n" "$protected_digests" "$top_digest" "$child_digests" | sed '/^$/d' | sort -u)
              done

              if [ "$inspect_failed" = "true" ]; then
                echo "--- Finished processing $pkg ---"
                continue
              fi
            fi

            # Consider deleting ONLY untagged versions, but skip any whose digest is referenced by protected tags
            # versions_json "name" is typically the digest like "sha256:..."
            candidates=$(echo "$versions_json" | jq -r '
              .[] | select((.metadata.container.tags | length) == 0) | "\(.id)\t\(.name)"
            ')

            if [ -z "$candidates" ]; then
              echo "No untagged images found for $pkg."
              echo "--- Finished processing $pkg ---"
              continue
            fi

            echo "Evaluating untagged versions for deletion..."
            while IFS=$'\t' read -r version_id version_digest; do
              if [ -z "$version_id" ] || [ -z "$version_digest" ]; then
                continue
              fi

              if [ -n "$protected_digests" ] && echo "$protected_digests" | grep -Fxq "$version_digest"; then
                echo "Keeping untagged version $version_id ($version_digest) because it is referenced by a protected tag"
                continue
              fi

              echo "Deleting untagged version $version_id ($version_digest)"
              gh api --method DELETE "$chosen_endpoint/packages/container/$pkg/versions/$version_id" --silent || \
                echo "Could not delete version $version_id for $pkg (may be restricted)"
            done <<< "$candidates"

            echo "--- Finished processing $pkg ---"
        env:
          GH_TOKEN: ${{ secrets.PACKAGES_BOT_PAT }}
